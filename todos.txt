================================================================================
Paperless-Dedupe — Implementation Roadmap
================================================================================

This file tracks the full implementation timeline for the Paperless-Dedupe app,
a TypeScript rewrite of paperless-ngx-dedupe. It identifies and manages duplicate
documents within Paperless-NGX document management systems using MinHash/LSH for
efficient O(n log n) duplicate detection at scale (13,000+ documents).

Future LLM sessions should read this file to understand what's been done and
what comes next.
It should represent the current status of the project and you must keep this
document up to date at all times.

Whenever you complete a task in this list you must mark it as completed with a
x in the box.
When an entire phase is completed mark the phase as completed in the phase
heading.
The user will move the completed tasks to todos-completed.txt (do not consume
this document unless you require historical context on why something was done)

Whenever designing or implementing features or functionality or bug fixes the
below ADRs must be respected and complied with.

================================================================================
ARCHITECTURE DECISIONS
================================================================================

AD-001: TypeScript full-stack with SvelteKit
  - Single language across backend and frontend
  - SvelteKit 2 serves both API routes and UI from one process
  - adapter-node for Docker deployment
  - Svelte 5 runes for reactive UI components
  - Node.js >= 22 required

AD-002: Drizzle ORM with dialect-switching pattern
  - SQLite (better-sqlite3) as default/reference storage
  - Schema-as-code with Drizzle table definitions
  - DDL staleness detection with SHA-256 hash comparison

AD-003: pnpm monorepo with two packages
  - @paperless-dedupe/core: pure TS library (no web deps)
    - Deduplication engine, Paperless client, database schema, queries
    - Framework-agnostic, enabling future CLI tools and external clients
  - @paperless-dedupe/web: SvelteKit application
    - UI pages, API routes, SSE endpoints, hooks
  - Core can be imported by future CLI tools or SDK packages

AD-004: Single Docker container by default
  - SQLite volume mount for data persistence (no external database needed)
  - Multi-stage build for small image size
  - Health checks via /api/v1/health and /api/v1/ready

AD-005: Zod for runtime validation at system boundaries
  - Environment variable parsing and validation at startup
  - API request body/query parameter validation
  - Configuration object shapes
  - Response type narrowing
  - No Ajv needed — we have no external JSON Schema to validate against

AD-006: API-first design for external client support
  - SvelteKit API routes are the canonical interface for all data operations
  - All /api/v1/* routes MUST return JSON and work for any HTTP client
  - The full container (including frontend) is the deployment unit — external
    clients connect to the same running instance
  - CORS must be configurable so cross-origin clients can call the API
  - All API routes must have consistent error response shapes and proper HTTP
    status codes
  - API versioning via URL prefix (/api/v1/)
  - SvelteKit page load functions (+page.server.ts) should call the same query
    logic that API routes use, ensuring feature parity between the UI and
    external consumers. Shared query functions live in @paperless-dedupe/core

AD-007: MinHash/LSH implemented in pure TypeScript
  - The deduplication engine is implemented entirely in @paperless-dedupe/core
    with no native dependencies beyond better-sqlite3
  - MinHash uses deterministic hash functions seeded from a fixed PRNG for
    reproducible signatures: h_i(x) = (a_i * x + b_i) mod p
  - 3-gram word shingles for text tokenization
  - LSH band-based indexing for O(n log n) candidate pair discovery
  - Configurable permutations (default 192) and LSH bands (default 20)
  - Signatures serialized as Uint32Array → Buffer for compact database storage
  - This avoids any dependency on Python's datasketch or WASM bindings

AD-008: worker_threads + SQLite job table for background processing
  - No Redis or Celery dependency — single container deployment
  - A `job` table in SQLite serves as the persistent job queue
  - Long-running operations (sync, analysis, batch ops) run in Node.js
    worker_threads to avoid blocking the main SvelteKit event loop
  - The main thread creates job records, spawns workers, and reads progress
  - Workers update job.progress and job.status directly in the database
  - SQLite WAL mode enables concurrent reads from main thread while worker
    writes progress updates
  - Only one job of each type runs at a time (enforced by status check)

AD-009: Server-Sent Events for real-time progress
  - SSE is simpler than WebSocket and unidirectional (server → client), which
    is exactly what we need for progress updates
  - SvelteKit supports SSE natively via streaming responses
  - The client subscribes to GET /api/v1/jobs/:jobId/progress
  - The server polls the job table and streams progress updates
  - Falls back gracefully: UI can also poll GET /api/v1/jobs/:jobId for status

AD-010: Pino for structured logging
  - Pino provides fast, structured JSON logging with minimal overhead
  - Configurable log level via LOG_LEVEL environment variable
  - Child loggers for component-specific context (e.g. pino.child({ module: 'sync' }))
  - No OpenTelemetry tracing or metrics — keep it simple
  - Request logging via pino-http middleware in hooks.server.ts


================================================================================
PHASE 8b: POLISH & PRODUCTION SECONDARIES
================================================================================
[ ] Data export
    [ ] Export duplicate report as CSV
    [ ] Export configuration as JSON (backup/restore)

[ ] Comprehensive error pages (404, 500)

[ ] Mobile-responsive layout
    [ ] Responsive sidebar (collapsible on mobile)
    [ ] Duplicate comparison stacks vertically on small screens
    [ ] Table columns hide/show based on breakpoint

================================================================================
PHASE 8C: POLISH & PRODUCTION TIERTIES
================================================================================
[ ] User documentation
    [ ] README with setup guide, configuration reference, API guide
    [ ] Troubleshooting guide (common issues, Paperless connectivity, etc.)

================================================================================
PHASE 10: EXTRAS
================================================================================

[ ] Accessibility audit (WCAG 2.1 AA)
    [ ] Semantic HTML elements
    [ ] Keyboard navigation for all interactive elements
    [ ] Screen reader support for confidence scores and status badges
    [ ] Focus management in modals and wizards

================================================================================
PHASE 9: Additional Features
================================================================================

- Similarity visualization
  Graph/network view showing document clusters by similarity
  Interactive: click nodes to see document details, edges show scores

- CLI tool for running sync and analysis from command line
  (this is a key motivator for @paperless-dedupe/core being framework-independent)

- Client SDK package (@paperless-dedupe/sdk)
  Lightweight TypeScript HTTP client wrapping all /api/v1/* endpoints
  Type-safe request/response types shared with the API's Zod schemas


================================================================================
FUTURE IDEAS (UNSCHEDULED)
================================================================================

- AI metadata extraction using Vercel AI SDK
  Provider-agnostic: OpenAI, Anthropic, Ollama, etc.
  Suggest titles, correspondents, document types, tags, dates
  Per-field confidence scores, review-before-apply workflow
  This is a key future feature — defer until core dedup is solid

- OpenTelemetry integration
  Tracing for sync/analysis pipelines, request spans, DB query spans
  Only if debugging production issues becomes painful

- Notification system (webhook on new duplicates found)
  POST to configurable URL when analysis completes with new groups

- Mobile app consuming the API (AD-006 ensures API is ready for this)

- Configurable document retention policies
  Auto-archive resolved duplicate groups after N days
  Compact old job records

- Multi-instance support
  Manage duplicates across multiple Paperless-NGX instances
  Cross-instance duplicate detection




CLAUDE SHOULD IGNORE BELOW THIS LINE!

prompt text (already at start of instruction)
Consume todos.txt and follow all instructions within it. We are now ready to plan out and implement Phase 8a. Please make a comprehensive implementation plan for all tasks listed within the phase, ensuring we are comforming with all defined ADRs in todos.txt. Make use of subagents and agent teams where appropriate during the planning and implementation phases once the plan is approved. Ensure the todos.txt file is updated to mark each phase as complete once it is completed and ensure this initial prompt is included on any plan produced so it is not lost during context compaction.