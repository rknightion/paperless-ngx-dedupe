================================================================================
Paperless-Dedupe — Implementation Roadmap
================================================================================

This file tracks the full implementation timeline for the Paperless-Dedupe app,
a TypeScript rewrite of paperless-ngx-dedupe. It identifies and manages duplicate
documents within Paperless-NGX document management systems using MinHash/LSH for
efficient O(n log n) duplicate detection at scale (13,000+ documents).

Future LLM sessions should read this file to understand what's been done and
what comes next.
It should represent the current status of the project and you must keep this
document up to date at all times.

Whenever you complete a task in this list you must mark it as completed with a
x in the box.
When an entire phase is completed mark the phase as completed in the phase
heading.
The user will move the completed tasks to todos-completed.txt (do not consume
this document unless you require historical context on why something was done)

Whenever designing or implementing features or functionality or bug fixes the
below ADRs must be respected and complied with.

================================================================================
ARCHITECTURE DECISIONS
================================================================================

AD-001: TypeScript full-stack with SvelteKit
  - Single language across backend and frontend
  - SvelteKit 2 serves both API routes and UI from one process
  - adapter-node for Docker deployment
  - Svelte 5 runes for reactive UI components
  - Node.js >= 22 required

AD-002: Drizzle ORM with dialect-switching pattern
  - SQLite (better-sqlite3) as default/reference storage
  - Postgres support planned via parallel schema definitions (Phase 8)
  - Schema-as-code with Drizzle table definitions
  - DDL staleness detection with SHA-256 hash comparison

AD-003: pnpm monorepo with two packages
  - @paperless-dedupe/core: pure TS library (no web deps)
    - Deduplication engine, Paperless client, database schema, queries
    - Framework-agnostic, enabling future CLI tools and external clients
  - @paperless-dedupe/web: SvelteKit application
    - UI pages, API routes, SSE endpoints, hooks
  - Core can be imported by future CLI tools or SDK packages

AD-004: Single Docker container by default
  - SQLite volume mount for data persistence (no external database needed)
  - Optional Postgres sidecar via compose override
  - Multi-stage build for small image size
  - Health checks via /api/v1/health and /api/v1/ready

AD-005: Zod for runtime validation at system boundaries
  - Environment variable parsing and validation at startup
  - API request body/query parameter validation
  - Configuration object shapes
  - Response type narrowing
  - No Ajv needed — we have no external JSON Schema to validate against

AD-006: API-first design for external client support
  - SvelteKit API routes are the canonical interface for all data operations
  - All /api/v1/* routes MUST return JSON and work for any HTTP client
  - The full container (including frontend) is the deployment unit — external
    clients connect to the same running instance
  - CORS must be configurable so cross-origin clients can call the API
  - All API routes must have consistent error response shapes and proper HTTP
    status codes
  - API versioning via URL prefix (/api/v1/)
  - SvelteKit page load functions (+page.server.ts) should call the same query
    logic that API routes use, ensuring feature parity between the UI and
    external consumers. Shared query functions live in @paperless-dedupe/core

AD-007: MinHash/LSH implemented in pure TypeScript
  - The deduplication engine is implemented entirely in @paperless-dedupe/core
    with no native dependencies beyond better-sqlite3
  - MinHash uses deterministic hash functions seeded from a fixed PRNG for
    reproducible signatures: h_i(x) = (a_i * x + b_i) mod p
  - 3-gram word shingles for text tokenization
  - LSH band-based indexing for O(n log n) candidate pair discovery
  - Configurable permutations (default 192) and LSH bands (default 20)
  - Signatures serialized as Uint32Array → Buffer for compact database storage
  - This avoids any dependency on Python's datasketch or WASM bindings

AD-008: worker_threads + SQLite job table for background processing
  - No Redis or Celery dependency — single container deployment
  - A `job` table in SQLite serves as the persistent job queue
  - Long-running operations (sync, analysis, batch ops) run in Node.js
    worker_threads to avoid blocking the main SvelteKit event loop
  - The main thread creates job records, spawns workers, and reads progress
  - Workers update job.progress and job.status directly in the database
  - SQLite WAL mode enables concurrent reads from main thread while worker
    writes progress updates
  - Only one job of each type runs at a time (enforced by status check)

AD-009: Server-Sent Events for real-time progress
  - SSE is simpler than WebSocket and unidirectional (server → client), which
    is exactly what we need for progress updates
  - SvelteKit supports SSE natively via streaming responses
  - The client subscribes to GET /api/v1/jobs/:jobId/progress
  - The server polls the job table and streams progress updates
  - Falls back gracefully: UI can also poll GET /api/v1/jobs/:jobId for status

AD-010: Pino for structured logging
  - Pino provides fast, structured JSON logging with minimal overhead
  - Configurable log level via LOG_LEVEL environment variable
  - Child loggers for component-specific context (e.g. pino.child({ module: 'sync' }))
  - No OpenTelemetry tracing or metrics — keep it simple
  - Request logging via pino-http middleware in hooks.server.ts



================================================================================
PHASE 7: UI — DUPLICATE MANAGEMENT  ✅ COMPLETED
================================================================================

The primary user-facing feature: viewing, comparing, and resolving duplicate
document groups. This is where users spend most of their time.

[x] Duplicate groups list (packages/web/src/routes/duplicates/+page.svelte)
    [x] Paginated HTML table of duplicate groups (custom, not TanStack — poor Svelte 5 runes support)
    [x] Columns: primary doc title, member count, confidence score, status
    [x] Filters:
        - Confidence range (min/max number inputs)
        - Status: all, unreviewed, reviewed, resolved
        - Correspondent filter (deferred — requires schema/query changes)
        - Document type filter (deferred — requires schema/query changes)
    [x] Sort by confidence (desc), created date, member count
    [x] Bulk selection with checkboxes
    [x] Bulk actions bar (appears when items selected):
        - "Mark Reviewed" → POST /api/v1/batch/review
        - "Resolve Selected" → POST /api/v1/batch/resolve
        - "Delete Non-Primary" → POST /api/v1/batch/delete-non-primary
          (with confirmation dialog warning about irreversibility)
    [x] Click row to navigate to group detail

[x] Duplicate group detail (packages/web/src/routes/duplicates/[id]/+page.svelte)
    [x] Group header: confidence score, algorithm version, created date
    [x] Confidence score breakdown chart:
        - ECharts horizontal bar chart showing Jaccard, Fuzzy, Metadata, Filename
          component scores and their weights
    [x] Side-by-side document comparison:
        - Two-column layout showing primary vs selected secondary document
        - Document metadata: title, correspondent, type, tags, dates, file size
        - OCR text diff view (diff-match-patch, highlight differences)
        - Switch between secondary documents via tabs or dropdown
    [x] Member management:
        - List all group members with "primary" badge on current primary
        - "Set as Primary" button on each non-primary member
        - Link to document in Paperless-NGX (opens in new tab)
    [x] Action buttons:
        - "Mark as Reviewed" / "Unmark Reviewed"
        - "Resolve Group" (marks as resolved, keeps documents)
        - "Delete Non-Primary Documents" (destructive, with confirmation)
          Calls Paperless API to delete, then marks group as resolved

[x] Bulk operations wizard (packages/web/src/routes/duplicates/wizard/+page.svelte)
    [x] Step-by-step guided flow for resolving high-confidence groups:
        Step 1: Filter — select confidence threshold (e.g. 95%+)
                Show count of matching unresolved groups
        Step 2: Review — paginated list of matching groups with quick preview
                User can exclude individual groups from batch
        Step 3: Action — choose: "Mark all as reviewed", "Resolve all",
                or "Delete non-primary documents"
        Step 4: Confirm — summary of what will happen, require explicit confirm
        Step 5: Execute — progress bar showing batch operation status
        Step 6: Results — summary of completed/failed operations

[x] Shared components for duplicate management
    [x] DocumentCompare.svelte — side-by-side document metadata comparison
    [x] TextDiff.svelte — visual text diff highlighting (diff-match-patch)
    [x] ConfidenceBreakdown.svelte — component score visualization (ECharts horizontal bars)
    [x] GroupActionBar.svelte — action buttons for a single group

Additional completed work:
    [x] ConfirmDialog.svelte — native <dialog> modal for confirmation prompts
    [x] member_count sort added to core duplicateGroupFiltersSchema
    [x] Sidebar active state fixed for sub-routes (startsWith prefix matching)
    [x] URL-based filter/pagination state (bookmarkable, browser back/forward)


================================================================================
PHASE 8a: POLISH & PRODUCTION PRIORITIES  ✅ COMPLETED
================================================================================

[x] End-to-end Playwright test suite
    [x] Install Playwright, configure in packages/web/
    [x] Test sync workflow (mock Paperless API)
    [x] Test duplicate review workflow
    [x] Test settings page
    [x] Test bulk operations wizard

[x] CI/CD pipeline (GitHub Actions)
    [x] Lint + format check
    [x] Type check (svelte-check + tsc)
    [x] Unit tests (vitest)
    [x] E2E tests (playwright) (including setting up a paperless-ngx instance. See paperless-ngx repo for how they setup tests for guidance/inspiration)
    [x] Docker build verification
    [x] Automated release tagging

[x] Docker optimization
    [x] Minimize image size (multi-stage, .dockerignore)
    [x] Non-root user in container
    [x] Graceful shutdown handling

[x] Performance optimization
    [x] Virtual scrolling for long document/group lists (Skipped — duplicates list already paginated, max 50 rows, no benefit)
    [x] Lazy loading for OCR text in comparison views
    [x] Efficient pagination (cursor-based if needed for large datasets) (Deferred — offset/limit works fine at expected scale)

================================================================================
PHASE 8b: POLISH & PRODUCTION SECONDARIES
================================================================================
[ ] Data export
    [ ] Export duplicate report as CSV
    [ ] Export configuration as JSON (backup/restore)

[ ] Comprehensive error pages (404, 500)

[ ] Mobile-responsive layout
    [ ] Responsive sidebar (collapsible on mobile)
    [ ] Duplicate comparison stacks vertically on small screens
    [ ] Table columns hide/show based on breakpoint

================================================================================
PHASE 8C: POLISH & PRODUCTION TIERTIES
================================================================================
[ ] User documentation
    [ ] README with setup guide, configuration reference, API guide
    [ ] Troubleshooting guide (common issues, Paperless connectivity, etc.)

================================================================================
PHASE 10: EXTRAS
================================================================================

[ ] Accessibility audit (WCAG 2.1 AA)
    [ ] Semantic HTML elements
    [ ] Keyboard navigation for all interactive elements
    [ ] Screen reader support for confidence scores and status badges
    [ ] Focus management in modals and wizards

================================================================================
PHASE 9: Additional Features
================================================================================

- Similarity visualization
  Graph/network view showing document clusters by similarity
  Interactive: click nodes to see document details, edges show scores

- CLI tool for running sync and analysis from command line
  (this is a key motivator for @paperless-dedupe/core being framework-independent)

- Client SDK package (@paperless-dedupe/sdk)
  Lightweight TypeScript HTTP client wrapping all /api/v1/* endpoints
  Type-safe request/response types shared with the API's Zod schemas


================================================================================
FUTURE IDEAS (UNSCHEDULED)
================================================================================

- AI metadata extraction using Vercel AI SDK
  Provider-agnostic: OpenAI, Anthropic, Ollama, etc.
  Suggest titles, correspondents, document types, tags, dates
  Per-field confidence scores, review-before-apply workflow
  This is a key future feature — defer until core dedup is solid

- OpenTelemetry integration
  Tracing for sync/analysis pipelines, request spans, DB query spans
  Only if debugging production issues becomes painful

- Notification system (webhook on new duplicates found)
  POST to configurable URL when analysis completes with new groups

- Mobile app consuming the API (AD-006 ensures API is ready for this)

- Configurable document retention policies
  Auto-archive resolved duplicate groups after N days
  Compact old job records

- Multi-instance support
  Manage duplicates across multiple Paperless-NGX instances
  Cross-instance duplicate detection




CLAUDE SHOULD IGNORE BELOW THIS LINE!

prompt text (already at start of instruction)
Consume todos.txt and follow all instructions within it. We are now ready to plan out and implement Phase 8a. Please make a comprehensive implementation plan for all tasks listed within the phase, ensuring we are comforming with all defined ADRs in todos.txt. Make use of subagents and agent teams where appropriate during the planning and implementation phases once the plan is approved. Ensure the todos.txt file is updated to mark each phase as complete once it is completed and ensure this initial prompt is included on any plan produced so it is not lost during context compaction.